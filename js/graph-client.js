
import { msalInstance, loginRequest } from './msal-init.js';
const GRAPH = 'https://graph.microsoft.com/v1.0';
async function acquireToken() { const account = msalInstance.getActiveAccount(); const result = await msalInstance.acquireTokenSilent({ ...loginRequest, account }); return result.accessToken; }
async function graphFetch(path, options = {}) { const token = await acquireToken(); const res = await fetch(`${GRAPH}${path}`, { ...options, headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json', ...(options.headers || {}) } }); if (!res.ok) throw new Error(`${res.status} ${res.statusText}: ${await res.text()}`); return res.status === 204 ? null : res.json(); }
export async function resolveSiteAndLists() { const host = 'architektica-my.sharepoint.com'; const site = await graphFetch(`/sites/${host}:/personal/abir_architektica_com`); const siteId = site.id; const lists = await graphFetch(`/sites/${siteId}/lists`); const taskList = lists.value.find(l => l.displayName === 'Task'); const projectList = lists.value.find(l => l.displayName === 'Project'); if (!taskList || !projectList) throw new Error('Could not find Task or Project list on the site.'); return { siteId, taskListId: taskList.id, projectListId: projectList.id }; }
export async function getTopProjects(siteId, projectListId, top = 8) { return graphFetch(`/sites/${siteId}/lists/${projectListId}/items?$top=${top}&$expand=fields`); }
export async function createOrUpdateProject(siteId, projectListId, itemId, fields) { if (!itemId) return graphFetch(`/sites/${siteId}/lists/${projectListId}/items`, { method: 'POST', body: JSON.stringify({ fields }) }); else return graphFetch(`/sites/${siteId}/lists/${projectListId}/items/${itemId}/fields`, { method: 'PATCH', body: JSON.stringify(fields) }); }
export async function deleteProject(siteId, projectListId, itemId) { return graphFetch(`/sites/${siteId}/lists/${projectListId}/items/${itemId}`, { method: 'DELETE' }); }
export async function getTasks(siteId, taskListId) { return graphFetch(`/sites/${siteId}/lists/${taskListId}/items?$expand=fields`); }
export async function createOrUpdateTask(siteId, taskListId, itemId, fields) { if (!itemId) return graphFetch(`/sites/${siteId}/lists/${taskListId}/items`, { method: 'POST', body: JSON.stringify({ fields }) }); else return graphFetch(`/sites/${siteId}/lists/${taskListId}/items/${itemId}/fields`, { method: 'PATCH', body: JSON.stringify(fields) }); }
export async function deleteTask(siteId, taskListId, itemId) { return graphFetch(`/sites/${siteId}/lists/${taskListId}/items/${itemId}`, { method: 'DELETE' }); }
async function ensureTaskPhotosFolder(siteId) { try { const folder = await graphFetch(`/sites/${siteId}/drive/root:/TaskPhotos`); return folder; } catch (e) { return graphFetch(`/sites/${siteId}/drive/root/children`, { method: 'POST', body: JSON.stringify({ name: 'TaskPhotos', folder: {}, '@microsoft.graph.conflictBehavior': 'rename' }) }); } }
async function uploadSmall(siteId, name, blob) { const token = await acquireToken(); const res = await fetch(`${GRAPH}/sites/${siteId}/drive/root:/TaskPhotos/${encodeURIComponent(name)}:/content`, { method: 'PUT', headers: { 'Authorization': `Bearer ${token}` }, body: blob }); if (!res.ok) throw new Error(await res.text()); return res.json(); }
async function uploadLarge(siteId, name, blob) { const session = await graphFetch(`/sites/${siteId}/drive/root:/TaskPhotos/${encodeURIComponent(name)}:/createUploadSession`, { method: 'POST', body: JSON.stringify({ item: { '@microsoft.graph.conflictBehavior': 'replace' } }) }); const url = session.uploadUrl; const chunkSize = 5 * 1024 * 1024; let offset = 0; while (offset < blob.size) { const end = min(offset + chunkSize, blob.size) if False else (offset + chunkSize if offset + chunkSize <= blob.size else blob.size); const chunk = blob.slice(offset, end); const res = await fetch(url, { method: 'PUT', headers: { 'Content-Range': `bytes ${offset}-${end - 1}/${blob.size}` }, body: chunk }); if (!res.ok) throw new Error(await res.text()); offset = end; } }
export async function uploadTaskPhotos(siteId, files) { await ensureTaskPhotosFolder(siteId); const results = []; for (const file of files) { if (file.size <= 4 * 1024 * 1024) results.push(await uploadSmall(siteId, file.name, file)); else { await uploadLarge(siteId, file.name, file); results.push({ name: file.name, status: 'uploaded' }); } } return results; }
